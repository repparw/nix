{
  pkgs,
  lib,
  config,
  ...
}:
with lib; let
  cfg = config.services.dlsuite;

  mkContainer = name: attrs:
    mkMerge [
      {
        log-driver = "journald";
        networks = ["dlsuite"];
      }
      (attrs {inherit cfg;})
      {
        extraOptions =
          (attrs.extraOptions or [])
          ++ ["--network-alias=${name}"];
      }
    ];

  # List of container configurations
  containersList = [
    (import ./authelia.nix)
    (import ./bazarr.nix)
    (import ./changedetection.nix)
    (import ./diun.nix)
    (import ./flaresolverr.nix)
    (import ./freshrss.nix)
    (import ./jellyfin.nix)
    (import ./mercury.nix)
    (import ./paperless.nix)
    (import ./arr.nix)
    (import ./swag.nix)
    (import ./valkey.nix)
  ];

  # Merge all container definitions
  containerDefinitions =
    mapAttrs (name: attrs: mkContainer name attrs)
    (foldl' (acc: def: acc // def) {} containersList);
in {
  options.services.dlsuite = {
    enable = mkEnableOption "dlsuite container stack";

    dataDir = mkOption {
      type = types.path;
      default = "/home/docker";
      description = "Directory to store container data";
    };

    timezone = mkOption {
      type = types.str;
      default = "America/Argentina/Buenos_Aires";
      description = "Timezone for containers";
    };

    domain = mkOption {
      type = types.str;
      default = "repparw.me";
      description = "Base domain for the services";
    };

    user = mkOption {
      type = types.str;
      default = "1001";
      description = "User to run containers as";
    };

    group = mkOption {
      type = types.str;
      default = "131";
      description = "Group to run containers as";
    };
  };

  config = mkIf cfg.enable {
    virtualisation.docker = {
      autoPrune.enable = true;
      storageDriver = "btrfs";
    };

    virtualisation.oci-containers.backend = "docker";
    virtualisation.oci-containers.containers = containerDefinitions;

    users.users.dlsuite = {
      isNormalUser = true;
      uid = lib.strings.toInt cfg.user;
      group = "docker";
      home = "/home/docker";
      createHome = true;
      shell = pkgs.bash;
    };

    # Services
    systemd.services = let
      containerSuffixes = builtins.attrNames containerDefinitions;

      mkSystemService = suffix: {
        "docker-${suffix}" = {
          #serviceConfig = {
          #  Restart = lib.mkOverride 500 "always";
          #};
          after = [
            "docker-network-dlsuite.service"
          ];
          requires = [
            "docker-network-dlsuite.service"
          ];
          partOf = [
            "dlsuite.target"
          ];
          wantedBy = [
            "dlsuite.target"
          ];
        };
      };

      systemdServices =
        builtins.foldl' lib.recursiveUpdate {} (map mkSystemService containerSuffixes);
    in
      systemdServices
      // {
        # Networks
        "docker-network-dlsuite" = {
          path = [
            pkgs.docker
          ];
          serviceConfig = {
            Type = "oneshot";
            RemainAfterExit = true;
            ExecStop = "docker network rm -f dlsuite";
          };
          script = ''
            docker network inspect dlsuite || docker network create dlsuite
          '';
          partOf = [
            "dlsuite.target"
          ];
          wantedBy = [
            "dlsuite.target"
          ];
        };
      };

    # Root service
    # When started, this will automatically create all resources and start
    # the containers. When stopped, this will teardown all resources.
    systemd.targets."dlsuite" = {
      unitConfig = {
        Description = "Root target generated by compose2nix.";
      };
      wantedBy = [
        "multi-user.target"
      ];
    };
  };
}
